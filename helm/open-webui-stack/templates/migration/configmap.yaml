{{- if .Values.migration.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "open-webui-stack.migration.fullname" . }}-script
  labels:
    {{- include "open-webui-stack.migration.labels" . | nindent 4 }}
data:
  restore-to-openwebui.py: |
    #!/usr/bin/env python3
    """
    LibreChat to Open WebUI Migration Script

    This script migrates data from a LibreChat MongoDB backup to Open WebUI.
    Run this inside the Open WebUI environment or with access to its database.

    Usage:
        # Set environment variables
        export BACKUP_DIR="./librechat-backup-20260113-140000"
        export DATA_DIR="/app/backend/data"  # Open WebUI data directory
        export DATABASE_URL="sqlite:///path/to/webui.db"  # Optional, auto-detected

        # Preview migration (no changes made)
        python restore-to-openwebui.py --dry-run

        # Run actual migration
        python restore-to-openwebui.py

        # Prefer imported passwords for duplicate emails
        python restore-to-openwebui.py --prefer-import-password

    Requirements:
        - Python 3.10+
        - SQLAlchemy (only for actual migration, not dry-run)
        - Access to Open WebUI models (only for actual migration)

    What gets migrated:
        - Users (email/password only, all set to "user" role)
        - Files (copied to Open WebUI uploads directory)
        - Conversations with full message history
        - Prompts (flattened from PromptGroup + Prompt)
        - Agents (converted to Open WebUI models)
    """
    import argparse
    import json
    import uuid
    import os
    import shutil
    from datetime import datetime
    from pathlib import Path
    from typing import Dict, List, Optional
    from dataclasses import dataclass, field

    # Global flags
    DRY_RUN = False
    PREFER_IMPORT_PASSWORD = False

    # Configuration - set these via environment variables or edit directly
    BACKUP_DIR = Path(os.getenv("BACKUP_DIR", "./librechat-backup"))
    OPENWEBUI_DATA_DIR = Path(os.getenv("DATA_DIR", "./data"))
    OPENWEBUI_UPLOAD_DIR = OPENWEBUI_DATA_DIR / "uploads"

    # ID mapping tables (populated during migration)
    user_id_map: Dict[str, str] = {}  # librechat_id -> openwebui_uuid
    file_id_map: Dict[str, str] = {}  # librechat_file_id -> openwebui_file_id


    @dataclass
    class MigrationStats:
        """Track migration statistics."""
        users: int = 0
        conversations: int = 0
        messages: int = 0
        files: int = 0
        prompts: int = 0
        agents: int = 0
        errors: List[str] = field(default_factory=list)


    # =============================================================================
    # UTILITY FUNCTIONS
    # =============================================================================

    def load_json(filename: str) -> List[dict]:
        """
        Load newline-delimited JSON from mongoexport.

        Args:
            filename: Name of JSON file in BACKUP_DIR/data/

        Returns:
            List of parsed documents
        """
        filepath = BACKUP_DIR / "data" / filename
        if not filepath.exists():
            print(f"  Warning: {filename} not found, skipping")
            return []

        documents = []
        with open(filepath, encoding="utf-8") as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line:
                    continue
                try:
                    documents.append(json.loads(line))
                except json.JSONDecodeError as e:
                    print(f"  Warning: Failed to parse line {line_num} in {filename}: {e}")

        return documents


    def parse_mongo_date(date_obj) -> int:
        """
        Convert MongoDB date to Unix epoch (seconds).

        Handles various MongoDB date formats:
        - {"$date": "2026-01-13T14:00:00Z"}
        - {"$date": 1736776800000}
        - Python datetime object
        """
        if date_obj is None:
            return int(datetime.utcnow().timestamp())

        if isinstance(date_obj, dict) and "$date" in date_obj:
            date_value = date_obj["$date"]
            if isinstance(date_value, str):
                # ISO format string
                try:
                    dt = datetime.fromisoformat(date_value.replace("Z", "+00:00"))
                    return int(dt.timestamp())
                except ValueError:
                    return int(datetime.utcnow().timestamp())
            elif isinstance(date_value, (int, float)):
                # Milliseconds since epoch
                return int(date_value // 1000)

        if isinstance(date_obj, datetime):
            return int(date_obj.timestamp())

        return int(datetime.utcnow().timestamp())


    def get_mongo_id(obj) -> str:
        """
        Extract string ID from MongoDB ObjectId.

        Handles:
        - {"$oid": "507f1f77bcf86cd799439011"}
        - Plain string
        """
        if obj is None:
            return ""
        if isinstance(obj, dict) and "$oid" in obj:
            return obj["$oid"]
        return str(obj)


    # =============================================================================
    # MODEL MAPPING CONFIGURATION
    # =============================================================================

    # Default fallback model when no mapping exists
    # Set this to a model that's guaranteed to be available in your Open WebUI instance
    DEFAULT_BASE_MODEL = os.getenv("MIGRATION_DEFAULT_MODEL", "gpt-4o")

    # Model name mapping for LibreChat provider+model -> Open WebUI base_model_id
    # Models not in this mapping will use DEFAULT_BASE_MODEL
    MODEL_MAPPING = {
        # OpenAI models
        ("openAI", "gpt-4"): "gpt-4",
        ("openAI", "gpt-4-turbo"): "gpt-4-turbo",
        ("openAI", "gpt-4-turbo-preview"): "gpt-4-turbo",
        ("openAI", "gpt-4o"): "gpt-4o",
        ("openAI", "gpt-4o-mini"): "gpt-4o-mini",
        ("openAI", "gpt-3.5-turbo"): "gpt-3.5-turbo",
        # Anthropic models
        ("anthropic", "claude-3-opus-20240229"): "claude-3-opus",
        ("anthropic", "claude-3-sonnet-20240229"): "claude-3-sonnet",
        ("anthropic", "claude-3-haiku-20240307"): "claude-3-haiku",
        ("anthropic", "claude-3-5-sonnet-20240620"): "claude-3.5-sonnet",
        ("anthropic", "claude-3-5-sonnet-20241022"): "claude-3.5-sonnet",
        # Add more mappings as needed for your available models
    }


    def resolve_base_model_id(provider: str, model: str) -> tuple:
        """
        Resolve LibreChat provider+model to Open WebUI base_model_id.

        Args:
            provider: LibreChat provider (e.g., "openAI", "anthropic")
            model: Model name (e.g., "gpt-4o", "claude-3-5-sonnet-20241022")

        Returns:
            Tuple of (base_model_id, used_fallback)
        """
        # Try exact match first
        key = (provider, model)
        if key in MODEL_MAPPING:
            return MODEL_MAPPING[key], False

        # Try with lowercase provider
        key = (provider.lower(), model)
        if key in MODEL_MAPPING:
            return MODEL_MAPPING[key], False

        # Fall back to default model
        return DEFAULT_BASE_MODEL, True


    def map_librechat_tools_to_capabilities(tools: List[str]) -> dict:
        """
        Map LibreChat tool names to Open WebUI capability flags.

        Args:
            tools: List of LibreChat tool names

        Returns:
            Dict of Open WebUI capability flags
        """
        capabilities = {
            "vision": True,  # Default to True, base model will validate
            "file_upload": False,
            "web_search": False,
            "image_generation": False,
            "code_interpreter": False,
            "citations": True,
            "status_updates": True,
            "usage": False,
        }

        tool_capability_map = {
            "file_search": "file_upload",
            "retrieval": "file_upload",
            "web_search": "web_search",
            "code_interpreter": "code_interpreter",
            "execute_code": "code_interpreter",
        }

        for tool in tools:
            if tool in tool_capability_map:
                capabilities[tool_capability_map[tool]] = True

        return capabilities


    # =============================================================================
    # USER MIGRATION
    # =============================================================================

    def migrate_users(session) -> int:
        """
        Migrate users from LibreChat to Open WebUI.

        - Email/password users only (OAuth skipped)
        - All users set to "user" role
        - Passwords are bcrypt hashes - direct copy

        Returns:
            Number of users migrated
        """
        from open_webui.models.users import User
        from open_webui.models.auths import Auth

        users = load_json("users.json")
        count = 0

        for user in users:
            old_id = get_mongo_id(user.get("_id"))
            new_id = str(uuid.uuid4())
            user_id_map[old_id] = new_id

            email = user.get("email", "").lower().strip()
            if not email:
                print(f"  Skipping user without email: {old_id}")
                continue

            # Check for existing user by email
            existing = session.query(User).filter(User.email == email).first()
            if existing:
                if PREFER_IMPORT_PASSWORD and user.get("password"):
                    # Update existing Auth record with LibreChat password
                    existing_auth = session.query(Auth).filter(Auth.id == existing.id).first()
                    if existing_auth:
                        existing_auth.password = user.get("password")
                        print(f"  Updated password for existing user: {email}")
                    else:
                        print(f"  Skipping duplicate (no auth record): {email}")
                else:
                    print(f"  Skipping duplicate email: {email}")
                user_id_map[old_id] = existing.id  # Map to existing user
                continue

            # Create Auth record (password is bcrypt - direct copy)
            auth = Auth(
                id=new_id,
                email=email,
                password=user.get("password", ""),
                active=True,
            )

            # Create User record
            owui_user = User(
                id=new_id,
                email=email,
                username=user.get("username"),
                role="user",  # Force all to user role per requirement
                name=user.get("name") or user.get("username") or email.split("@")[0],
                profile_image_url=user.get("avatar", "/user.png"),
                settings={},
                oauth=None,  # No OAuth per requirement
                last_active_at=int(datetime.utcnow().timestamp()),
                created_at=parse_mongo_date(user.get("createdAt")),
                updated_at=parse_mongo_date(user.get("updatedAt")),
            )

            session.add(auth)
            session.add(owui_user)
            count += 1

        return count


    # =============================================================================
    # FILE MIGRATION
    # =============================================================================

    def migrate_files(session) -> int:
        """
        Migrate files from LibreChat to Open WebUI.

        - Copies physical files to Open WebUI uploads directory
        - Creates database records
        - Skips non-local files (S3, OpenAI, etc.)

        Returns:
            Number of files migrated
        """
        from open_webui.models.files import Files, FileForm

        files = load_json("files.json")
        count = 0

        OPENWEBUI_UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

        for file_doc in files:
            old_file_id = file_doc.get("file_id")
            old_user_id = get_mongo_id(file_doc.get("user"))
            new_user_id = user_id_map.get(old_user_id)

            if not new_user_id:
                print(f"  Skipping file for unknown user: {old_user_id}")
                continue
            if not old_file_id:
                continue

            # Skip non-local files (S3, OpenAI, etc.)
            source = file_doc.get("source", "local")
            if source not in ("local", "", None):
                print(f"  Skipping non-local file: {old_file_id} (source: {source})")
                continue

            # Find physical file in backup
            old_filepath = file_doc.get("filepath", "")
            filename = file_doc.get("filename", "unknown")

            # LibreChat paths: /uploads/{userId}/{file_id}__{filename}
            # or /images/{userId}/{file_id}__{filename}
            source_file = None

            # Try to find file based on filepath
            if old_filepath.startswith("/uploads/"):
                relative_path = old_filepath.lstrip("/uploads/")
                source_file = BACKUP_DIR / "files" / "uploads" / relative_path
            elif old_filepath.startswith("/images/"):
                relative_path = old_filepath.lstrip("/images/")
                source_file = BACKUP_DIR / "files" / "images" / relative_path

            # Try alternative path constructions if not found
            if not source_file or not source_file.exists():
                for subdir in ["uploads", "images"]:
                    alt_path = BACKUP_DIR / "files" / subdir / old_user_id / f"{old_file_id}__{filename}"
                    if alt_path.exists():
                        source_file = alt_path
                        break
                    # Also try without double underscore
                    alt_path = BACKUP_DIR / "files" / subdir / old_user_id / filename
                    if alt_path.exists():
                        source_file = alt_path
                        break

            if not source_file or not source_file.exists():
                print(f"  Skipping file not found in backup: {old_file_id} ({filename})")
                continue

            # Create new file in Open WebUI format
            new_file_id = str(uuid.uuid4())
            file_id_map[old_file_id] = new_file_id
            new_filename = f"{new_file_id}_{filename}"
            new_path = OPENWEBUI_UPLOAD_DIR / new_filename

            # Copy file
            try:
                shutil.copy2(source_file, new_path)
            except Exception as e:
                print(f"  Failed to copy file {old_file_id}: {e}")
                continue

            # Create DB record
            try:
                Files.insert_new_file(
                    new_user_id,
                    FileForm(
                        id=new_file_id,
                        filename=filename,
                        path=str(new_path),
                        data={},
                        meta={
                            "name": filename,
                            "content_type": file_doc.get("type", "application/octet-stream"),
                            "size": file_doc.get("bytes", 0),
                        },
                    ),
                )
                count += 1
            except Exception as e:
                print(f"  Failed to create file record {old_file_id}: {e}")
                # Clean up copied file
                if new_path.exists():
                    new_path.unlink()

        return count


    # =============================================================================
    # CONVERSATION/CHAT MIGRATION
    # =============================================================================

    def build_message_tree(messages: List[dict]) -> dict:
        """
        Build Open WebUI message structure from LibreChat messages.

        LibreChat stores messages as separate documents with parentMessageId.
        Open WebUI stores them as a nested dict with childrenIds.

        Args:
            messages: List of LibreChat message documents

        Returns:
            Dict of message_id -> message object for Open WebUI chat.history.messages
        """
        messages_map = {}
        children_map = {}

        # First pass: create message objects
        for msg in messages:
            msg_id = msg.get("messageId")
            if not msg_id:
                continue

            parent_id = msg.get("parentMessageId")
            # Track children for second pass
            if parent_id and parent_id != "00000000-0000-0000-0000-000000000000":
                if parent_id not in children_map:
                    children_map[parent_id] = []
                children_map[parent_id].append(msg_id)

            # Map files to Open WebUI format
            files = []
            for file_ref in msg.get("files", []):
                old_file_id = file_ref.get("file_id")
                new_file_id = file_id_map.get(old_file_id)
                if new_file_id:
                    files.append({
                        "type": "file",
                        "id": new_file_id,
                        "name": file_ref.get("filename", ""),
                        "url": new_file_id,
                        "content_type": file_ref.get("type", ""),
                        "size": file_ref.get("bytes", 0),
                        "status": "uploaded",
                    })

            messages_map[msg_id] = {
                "id": msg_id,
                "role": "user" if msg.get("isCreatedByUser") else "assistant",
                "content": msg.get("text", ""),
                "parentId": parent_id if parent_id != "00000000-0000-0000-0000-000000000000" else None,
                "childrenIds": [],
                "timestamp": parse_mongo_date(msg.get("createdAt")),
                "model": msg.get("model"),
            }

            # Only add files if there are any
            if files:
                messages_map[msg_id]["files"] = files

        # Second pass: populate children
        for msg_id, children in children_map.items():
            if msg_id in messages_map:
                messages_map[msg_id]["childrenIds"] = children

        return messages_map


    def migrate_conversations(session) -> int:
        """
        Migrate conversations with their messages.

        LibreChat stores conversations and messages as separate collections.
        Open WebUI stores them as a single JSON structure in the chat column.

        Returns:
            Number of conversations migrated
        """
        from open_webui.models.chats import Chat
        from open_webui.models.tags import Tags

        conversations = load_json("conversations.json")
        messages = load_json("messages.json")
        count = 0

        # Group messages by conversation
        messages_by_convo = {}
        for msg in messages:
            cid = msg.get("conversationId")
            if cid:
                if cid not in messages_by_convo:
                    messages_by_convo[cid] = []
                messages_by_convo[cid].append(msg)

        for convo in conversations:
            convo_id = convo.get("conversationId")
            old_user_id = get_mongo_id(convo.get("user"))
            new_user_id = user_id_map.get(old_user_id)

            if not new_user_id:
                print(f"  Skipping conversation for unknown user: {old_user_id}")
                continue
            if not convo_id:
                continue

            convo_messages = messages_by_convo.get(convo_id, [])
            messages_map = build_message_tree(convo_messages)

            # Find current (last) message
            current_id = None
            if messages_map:
                current_id = max(
                    messages_map.keys(),
                    key=lambda k: messages_map[k].get("timestamp", 0),
                )

            # Convert tags to Open WebUI format (ID-based)
            tag_ids = []
            for tag_name in convo.get("tags", []):
                tag_id = tag_name.replace(" ", "_").lower()
                tag_ids.append(tag_id)
                # Create tag if needed
                try:
                    Tags.insert_new_tag(tag_name, new_user_id)
                except Exception:
                    pass  # Tag may already exist

            new_chat_id = str(uuid.uuid4())
            chat = Chat(
                id=new_chat_id,
                user_id=new_user_id,
                title=convo.get("title", "New Chat"),
                chat={
                    "history": {
                        "currentId": current_id,
                        "messages": messages_map,
                    }
                },
                created_at=parse_mongo_date(convo.get("createdAt")),
                updated_at=parse_mongo_date(convo.get("updatedAt")),
                archived=convo.get("isArchived", False),
                pinned=False,
                meta={"tags": tag_ids} if tag_ids else {},
                folder_id=None,
            )

            session.add(chat)
            count += 1

        return count


    # =============================================================================
    # PROMPT MIGRATION
    # =============================================================================

    def migrate_prompts(session) -> int:
        """
        Migrate prompts from LibreChat to Open WebUI.

        LibreChat uses PromptGroup + Prompt (versioned).
        Open WebUI uses a single Prompt table (command-keyed).
        Migration uses the production/active version.

        Returns:
            Number of prompts migrated
        """
        from open_webui.models.prompts import Prompts, PromptForm

        prompt_groups = load_json("promptgroups.json")
        prompts = load_json("prompts.json")
        count = 0

        # Index prompts by groupId
        prompts_by_group = {}
        for prompt in prompts:
            group_id = get_mongo_id(prompt.get("groupId"))
            if group_id not in prompts_by_group:
                prompts_by_group[group_id] = []
            prompts_by_group[group_id].append(prompt)

        for group in prompt_groups:
            group_id = get_mongo_id(group.get("_id"))
            old_user_id = get_mongo_id(group.get("author"))
            new_user_id = user_id_map.get(old_user_id)

            if not new_user_id:
                continue

            # Get production prompt (or first available)
            group_prompts = prompts_by_group.get(group_id, [])
            prod_id = get_mongo_id(group.get("productionId")) if group.get("productionId") else None
            active_prompt = None

            for p in group_prompts:
                if prod_id and get_mongo_id(p.get("_id")) == prod_id:
                    active_prompt = p
                    break
            if not active_prompt and group_prompts:
                active_prompt = group_prompts[0]

            if not active_prompt:
                continue

            command = group.get("command", "").strip("/")
            if not command:
                command = group.get("name", "").replace(" ", "_").lower()

            try:
                Prompts.insert_new_prompt(
                    new_user_id,
                    PromptForm(
                        command=command,
                        title=group.get("name", command),
                        content=active_prompt.get("prompt", ""),
                    ),
                )
                count += 1
            except Exception as e:
                print(f"  Failed to migrate prompt '{command}': {e}")

        return count


    # =============================================================================
    # AGENT TO MODEL MIGRATION
    # =============================================================================

    def migrate_agents_to_models(session, admin_user_id: str) -> tuple:
        """
        Migrate LibreChat agents to Open WebUI models.

        Args:
            session: SQLAlchemy session
            admin_user_id: User ID to own the created models

        Returns:
            Tuple of (count, fallbacks) where fallbacks is list of
            (name, original_model, fallback_model) for agents that used fallback
        """
        from open_webui.models.models import Model

        agents = load_json("agents.json")
        count = 0
        skipped = []
        fallbacks = []

        for agent in agents:
            agent_id = agent.get("id")
            name = agent.get("name", "Unnamed Agent")
            provider = agent.get("provider", "openAI")
            model_name = agent.get("model", "")

            if not model_name:
                skipped.append((name, "No model specified"))
                continue

            # Resolve base model
            base_model_id, used_fallback = resolve_base_model_id(provider, model_name)
            if used_fallback:
                fallbacks.append((name, f"{provider}/{model_name}", base_model_id))

            # Build params from agent configuration
            params = {}
            if agent.get("instructions"):
                params["system"] = agent["instructions"]

            model_params = agent.get("model_parameters", {})
            if model_params.get("temperature") is not None:
                params["temperature"] = float(model_params["temperature"])
            if model_params.get("max_output_tokens") is not None:
                params["max_tokens"] = int(model_params["max_output_tokens"])
            if model_params.get("top_p") is not None:
                params["top_p"] = float(model_params["top_p"])
            if model_params.get("frequency_penalty") is not None:
                params["frequency_penalty"] = float(model_params["frequency_penalty"])
            if model_params.get("presence_penalty") is not None:
                params["presence_penalty"] = float(model_params["presence_penalty"])

            # Build capabilities from tools
            tools = agent.get("tools", [])
            capabilities = map_librechat_tools_to_capabilities(tools)

            # Build suggestion prompts from conversation starters
            suggestion_prompts = []
            for starter in agent.get("conversation_starters", []):
                suggestion_prompts.append({
                    "content": starter,
                    "title": [starter[:30] + "..." if len(starter) > 30 else starter, ""],
                })

            # Build meta
            meta = {
                "description": agent.get("description"),
                "capabilities": capabilities,
                "tags": [{"name": "migrated"}, {"name": "librechat-agent"}],
                "suggestion_prompts": suggestion_prompts if suggestion_prompts else None,
                "toolIds": [],
                "filterIds": [],
                "actionIds": [],
                "knowledge": [],
            }

            # Handle avatar
            avatar = agent.get("avatar")
            if avatar and isinstance(avatar, dict):
                meta["profile_image_url"] = avatar.get("filepath", "/static/favicon.png")
            else:
                meta["profile_image_url"] = "/static/favicon.png"

            # Create unique model ID (prefix with 'agent-' to avoid conflicts)
            model_id = f"agent-{agent_id}" if agent_id else f"agent-{name.lower().replace(' ', '-')}"

            now = int(datetime.utcnow().timestamp())

            try:
                owui_model = Model(
                    id=model_id,
                    user_id=admin_user_id,
                    base_model_id=base_model_id,
                    name=name,
                    params=params,
                    meta=meta,
                    access_control=None,  # Public to all users
                    is_active=True,
                    created_at=now,
                    updated_at=now,
                )

                session.add(owui_model)
                count += 1
            except Exception as e:
                print(f"  Failed to migrate agent '{name}': {e}")

        if skipped:
            print(f"   Skipped {len(skipped)} agents:")
            for name, reason in skipped:
                print(f"     - {name}: {reason}")

        if fallbacks:
            print(f"   Used fallback model for {len(fallbacks)} agents:")
            for name, original, fallback in fallbacks:
                print(f"     - {name}: {original} -> {fallback}")

        return count, fallbacks


    def generate_agent_migration_report(fallbacks: List[tuple]) -> str:
        """
        Generate a markdown report of agent->model migration for review.

        Args:
            fallbacks: List of (name, original_model, fallback_model) tuples

        Returns:
            Markdown report string
        """
        agents = load_json("agents.json")
        report = ["# Agent to Model Migration Report\n"]
        report.append(f"Generated: {datetime.utcnow().isoformat()}Z\n")
        report.append(f"Default fallback model: `{DEFAULT_BASE_MODEL}`\n")
        report.append("=" * 60 + "\n")

        for agent in agents:
            name = agent.get("name", "Unnamed")
            provider = agent.get("provider", "openAI")
            model = agent.get("model", "unknown")
            base_model, used_fallback = resolve_base_model_id(provider, model)
            tools = agent.get("tools", [])
            capabilities = map_librechat_tools_to_capabilities(tools)

            report.append(f"\n## {name}\n")
            report.append(f"**LibreChat ID**: `{agent.get('id')}`\n")
            report.append(f"**Open WebUI ID**: `agent-{agent.get('id')}`\n")

            if used_fallback:
                report.append(f"**Base Model**: `{base_model}` (FALLBACK - original: {provider}/{model})\n")
            else:
                report.append(f"**Base Model**: `{base_model}` (from {provider}/{model})\n")

            enabled_caps = [k for k, v in capabilities.items() if v]
            report.append(f"**Capabilities**: {', '.join(enabled_caps)}\n")

            if agent.get("instructions"):
                preview = agent["instructions"][:100]
                if len(agent["instructions"]) > 100:
                    preview += "..."
                report.append(f"**System Prompt Preview**: {preview}\n")

            if agent.get("actions"):
                report.append(f"\n**Manual Action Required**: This agent has custom actions:\n")
                for action_id in agent["actions"]:
                    report.append(f"  - `{action_id}` - Create as Open WebUI Tool/Function\n")

            report.append("\n" + "-" * 40 + "\n")

        # Summary section
        if fallbacks:
            report.append("\n## Model Fallback Summary\n")
            report.append(f"The following {len(fallbacks)} agents used the fallback model:\n\n")
            report.append("| Agent | Original Model | Fallback Model |\n")
            report.append("|-------|----------------|----------------|\n")
            for name, original, fallback in fallbacks:
                report.append(f"| {name} | {original} | {fallback} |\n")
            report.append("\nTo use specific models, add mappings to `MODEL_MAPPING` in the migration script and re-run.\n")

        return "\n".join(report)


    # =============================================================================
    # DRY RUN ANALYSIS
    # =============================================================================

    def analyze_backup() -> dict:
        """
        Analyze backup contents without making any changes.
        Returns detailed statistics about what would be migrated.
        """
        stats = {
            "users": {"total": 0, "with_email": 0, "with_password": 0, "oauth_only": 0},
            "files": {"total": 0, "local": 0, "remote": 0, "found_in_backup": 0},
            "conversations": {"total": 0, "with_messages": 0, "archived": 0},
            "messages": {"total": 0},
            "prompts": {"total": 0, "groups": 0},
            "agents": {"total": 0, "with_model": 0, "mapped": 0, "fallback": 0},
            "tags": set(),
            "issues": [],
        }

        # Analyze users
        users = load_json("users.json")
        stats["users"]["total"] = len(users)
        for user in users:
            email = user.get("email", "").strip()
            password = user.get("password", "")
            provider = user.get("provider", "local")

            if email:
                stats["users"]["with_email"] += 1
            if password:
                stats["users"]["with_password"] += 1
            if provider != "local" and not password:
                stats["users"]["oauth_only"] += 1

            # Build user ID map for later analysis
            old_id = get_mongo_id(user.get("_id"))
            if old_id and email:
                user_id_map[old_id] = f"preview-{old_id}"

        # Analyze files
        files = load_json("files.json")
        stats["files"]["total"] = len(files)
        for file_doc in files:
            source = file_doc.get("source", "local")
            if source in ("local", "", None):
                stats["files"]["local"] += 1
                # Check if file exists in backup
                old_filepath = file_doc.get("filepath", "")
                filename = file_doc.get("filename", "unknown")
                old_file_id = file_doc.get("file_id", "")
                old_user_id = get_mongo_id(file_doc.get("user"))

                found = False
                if old_filepath.startswith("/uploads/"):
                    path = BACKUP_DIR / "files" / "uploads" / old_filepath.lstrip("/uploads/")
                    if path.exists():
                        found = True
                elif old_filepath.startswith("/images/"):
                    path = BACKUP_DIR / "files" / "images" / old_filepath.lstrip("/images/")
                    if path.exists():
                        found = True

                if not found:
                    for subdir in ["uploads", "images"]:
                        alt_path = BACKUP_DIR / "files" / subdir / old_user_id / f"{old_file_id}__{filename}"
                        if alt_path.exists():
                            found = True
                            break

                if found:
                    stats["files"]["found_in_backup"] += 1
            else:
                stats["files"]["remote"] += 1

        # Analyze conversations and messages
        conversations = load_json("conversations.json")
        messages = load_json("messages.json")
        stats["conversations"]["total"] = len(conversations)
        stats["messages"]["total"] = len(messages)

        messages_by_convo = {}
        for msg in messages:
            cid = msg.get("conversationId")
            if cid:
                messages_by_convo[cid] = messages_by_convo.get(cid, 0) + 1

        for convo in conversations:
            convo_id = convo.get("conversationId")
            if convo_id and messages_by_convo.get(convo_id, 0) > 0:
                stats["conversations"]["with_messages"] += 1
            if convo.get("isArchived"):
                stats["conversations"]["archived"] += 1
            for tag in convo.get("tags", []):
                stats["tags"].add(tag)

        # Analyze prompts
        prompt_groups = load_json("promptgroups.json")
        prompts = load_json("prompts.json")
        stats["prompts"]["groups"] = len(prompt_groups)
        stats["prompts"]["total"] = len(prompts)

        # Analyze agents
        agents = load_json("agents.json")
        stats["agents"]["total"] = len(agents)
        for agent in agents:
            model_name = agent.get("model", "")
            provider = agent.get("provider", "openAI")
            if model_name:
                stats["agents"]["with_model"] += 1
                base_model, used_fallback = resolve_base_model_id(provider, model_name)
                if used_fallback:
                    stats["agents"]["fallback"] += 1
                else:
                    stats["agents"]["mapped"] += 1

        # Convert tags set to count
        stats["tags"] = len(stats["tags"])

        return stats


    def print_dry_run_report(stats: dict):
        """Print a formatted dry-run report."""
        print()
        print("=" * 60)
        print("DRY RUN ANALYSIS - No changes will be made")
        print("=" * 60)
        print()

        # Users
        print("USERS")
        print("-" * 40)
        print(f"  Total in backup:      {stats['users']['total']}")
        print(f"  With email:           {stats['users']['with_email']}")
        print(f"  With password:        {stats['users']['with_password']} (will migrate)")
        print(f"  OAuth-only:           {stats['users']['oauth_only']} (will skip)")
        print()

        # Files
        print("FILES")
        print("-" * 40)
        print(f"  Total in backup:      {stats['files']['total']}")
        print(f"  Local files:          {stats['files']['local']}")
        print(f"  Remote (S3, etc):     {stats['files']['remote']} (will skip)")
        print(f"  Found in backup:      {stats['files']['found_in_backup']} (will migrate)")
        missing = stats['files']['local'] - stats['files']['found_in_backup']
        if missing > 0:
            print(f"  Missing from backup:  {missing} (will skip)")
        print()

        # Conversations
        print("CONVERSATIONS")
        print("-" * 40)
        print(f"  Total:                {stats['conversations']['total']}")
        print(f"  With messages:        {stats['conversations']['with_messages']}")
        print(f"  Archived:             {stats['conversations']['archived']}")
        print(f"  Total messages:       {stats['messages']['total']}")
        print(f"  Unique tags:          {stats['tags']}")
        print()

        # Prompts
        print("PROMPTS")
        print("-" * 40)
        print(f"  Prompt groups:        {stats['prompts']['groups']} (will migrate)")
        print(f"  Prompt versions:      {stats['prompts']['total']} (latest per group)")
        print()

        # Agents
        print("AGENTS -> MODELS")
        print("-" * 40)
        print(f"  Total agents:         {stats['agents']['total']}")
        print(f"  With model config:    {stats['agents']['with_model']}")
        print(f"  Model mapped:         {stats['agents']['mapped']}")
        print(f"  Using fallback:       {stats['agents']['fallback']} (-> {DEFAULT_BASE_MODEL})")
        print()

        # Summary
        print("=" * 60)
        print("MIGRATION SUMMARY")
        print("=" * 60)
        print(f"  Users to migrate:     ~{stats['users']['with_password']}")
        print(f"  Files to copy:        ~{stats['files']['found_in_backup']}")
        print(f"  Conversations:        ~{stats['conversations']['total']}")
        print(f"  Prompts:              ~{stats['prompts']['groups']}")
        print(f"  Agents -> Models:     ~{stats['agents']['with_model']}")
        print()
        print("Run without --dry-run to perform the actual migration.")
        print()


    # =============================================================================
    # MAIN MIGRATION
    # =============================================================================

    def main():
        """Run the full migration."""
        global DRY_RUN, PREFER_IMPORT_PASSWORD

        # Parse command line arguments
        parser = argparse.ArgumentParser(
            description="Migrate LibreChat data to Open WebUI",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="""
    Examples:
      python restore-to-openwebui.py --dry-run                  Preview what would be migrated
      python restore-to-openwebui.py                            Run the actual migration
      python restore-to-openwebui.py --prefer-import-password   Update passwords for duplicate emails

    Environment variables:
      BACKUP_DIR                 Path to extracted backup directory
      DATA_DIR                   Open WebUI data directory
      DATABASE_URL               Database connection string
      MIGRATION_DEFAULT_MODEL    Fallback model for unmapped agents
            """,
        )
        parser.add_argument(
            "--dry-run",
            action="store_true",
            help="Analyze backup and show what would be migrated without making changes",
        )
        parser.add_argument(
            "--prefer-import-password",
            action="store_true",
            help="For duplicate emails, update existing user's password with the imported one",
        )
        args = parser.parse_args()
        DRY_RUN = args.dry_run
        PREFER_IMPORT_PASSWORD = args.prefer_import_password

        print("=" * 60)
        print("LibreChat to Open WebUI Migration")
        if DRY_RUN:
            print("MODE: Dry Run (no changes will be made)")
        print("=" * 60)
        print(f"Backup directory: {BACKUP_DIR}")
        print(f"Data directory: {OPENWEBUI_DATA_DIR}")
        print(f"Upload directory: {OPENWEBUI_UPLOAD_DIR}")
        print()

        # Validate backup directory
        if not BACKUP_DIR.exists():
            print(f"ERROR: Backup directory not found: {BACKUP_DIR}")
            print("Set BACKUP_DIR environment variable to the extracted backup location")
            return 1

        if not (BACKUP_DIR / "data").exists():
            print(f"ERROR: No data/ subdirectory in backup: {BACKUP_DIR}")
            return 1

        # Dry run mode - analyze only
        if DRY_RUN:
            stats = analyze_backup()
            print_dry_run_report(stats)
            return 0

        # Import database dependencies only when actually running migration
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker

        # Connect to Open WebUI database
        db_url = os.getenv("DATABASE_URL", f"sqlite:///{OPENWEBUI_DATA_DIR}/webui.db")
        print(f"Database: {db_url}")
        print()

        engine = create_engine(db_url)
        Session = sessionmaker(bind=engine)
        session = Session()

        stats = MigrationStats()

        try:
            print("1. Migrating users...")
            stats.users = migrate_users(session)
            session.commit()
            print(f"   Migrated {stats.users} users")

            # Get first admin user ID for model ownership (or first migrated user)
            admin_user_id = next(iter(user_id_map.values()), None)
            if not admin_user_id:
                print("ERROR: No users migrated - cannot assign model ownership")
                return 1

            print("2. Migrating files...")
            stats.files = migrate_files(session)
            session.commit()
            print(f"   Migrated {stats.files} files")

            print("3. Migrating conversations...")
            stats.conversations = migrate_conversations(session)
            session.commit()
            print(f"   Migrated {stats.conversations} conversations")

            print("4. Migrating prompts...")
            stats.prompts = migrate_prompts(session)
            session.commit()
            print(f"   Migrated {stats.prompts} prompts")

            print("5. Migrating agents to models...")
            stats.agents, fallbacks = migrate_agents_to_models(session, admin_user_id)
            session.commit()
            print(f"   Migrated {stats.agents} agents to models")

            print("6. Generating migration report...")
            report = generate_agent_migration_report(fallbacks)
            report_path = BACKUP_DIR / "MIGRATION_REPORT.md"
            with open(report_path, "w", encoding="utf-8") as f:
                f.write(report)
            print(f"   Report saved to: {report_path}")

            print()
            print("=" * 60)
            print("MIGRATION COMPLETE")
            print("=" * 60)
            print(f"Users:         {stats.users}")
            print(f"Files:         {stats.files}")
            print(f"Conversations: {stats.conversations}")
            print(f"Prompts:       {stats.prompts}")
            print(f"Agents->Models: {stats.agents}")
            print()
            print(f"Migration report: {report_path}")
            print()
            print("Next steps:")
            print("1. Review MIGRATION_REPORT.md for any manual actions needed")
            print("2. Verify base model availability in Open WebUI")
            print("3. Test user logins and conversation access")
            print("4. Test migrated models (prefixed with 'agent-')")

            return 0

        except Exception as e:
            session.rollback()
            print(f"ERROR: Migration failed - {e}")
            import traceback
            traceback.print_exc()
            return 1
        finally:
            session.close()


    if __name__ == "__main__":
        exit(main())
{{- end }}
